# 六大设计原则

## 一、单一职责原则(Single Responsibility Principle，SRP)

​        ***应该有且仅有一个原因引起类的变更。因为是面向接口编程，对外暴露的是接口，所以单一职责原则应该是要求一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责。***

![单一职责原则](https://github.com/xiangtch/JavaKnowledge/blob/master/src/main/resources/doc/designPatterns/image/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99.png)

图1-5 中要用到类的组合，会增加类的复杂性，比较合理的设计应该是图 1-6 的设计，对于类的单一职责往往在实际中不好对职责的边界进行划分。

***单一职责原则的好处***：

- **类的复杂性降低**，实现什么职责都有清晰明确的定义
- **可读性提高**，复杂性降低，那当然可读性提高了
- **可维护性提高**，可读性提高，那当然更容易维护了
- **变更引起的风险降低**

单一职责原则适用于接口、类和方法。即一个方法尽可能的做一件事情。***单一职责原则使用建议，接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化，一个方法尽可能的做一件事情。***

## 二、里氏替换原则(Liskov Substitution Principle，LSP)

- 第一种定义：***如果对每一个类型为 S 的对象 o1，都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 S 是类型 T 的子类型。***

- 第二种定义： ***所有引用基类的地方必须能透明地使用其子类的对象。***即只要父类能出现的地方子类就可以出现，而且替换成子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是反过来就不行了，有子类出现的地方，父类未必能适应。

在面向对象的语言中，对应的就是继承机制。

**继承的优点：**

- ***代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性***
- ***提高代码的重用性***
- ***子类可以形似父类，但又异于父类***
- ***提高代码的可扩展性***
- ***提高产品或项目的开放性***

**继承的缺点：**

- ***继承是侵入性的。***只要继承，就必须拥有父类的所有属性和方法
- ***降低代码的灵活性。***子类必须拥有父类的属性和方法，让子类多了些约束
- ***增强了耦合性。***当父类的常量、变量和方法被修改时，需要考虑子类的修改。

**注意：**

- ***在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了 LSP 原则***
- ***如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子集成关系，采用依赖、聚集、组合等关系代替集成。***
- ***覆盖或实现父类的方法时输入参数可以被放大***
- ***覆写或实现父类的方法时输出结果可以被缩小***

## 三、依赖倒置原则(Dependence Inversion Principle，DIP)

该原则包含有三层含义：

- ***高层模块不应该依赖底层模块，两者都应该依赖其抽象***
- ***抽象不应该依赖细节***
- ***细节应该依赖抽象***

在 Java 语言中的表现就是：

- ***模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的***
- ***接口或抽象类不依赖于实现类***
- ***实现类依赖接口或抽象类***

也就是“面向接口编程”——OOD(Object-Oriented Design，面向对象设计)的精髓之一。

依赖的三种写法：

1. ***构造函数传递依赖对象***
2. ***Setter 方法传递依赖***
3. ***接口声明依赖对象（即接口注入）***

***依赖倒置原则的本质是通过抽象 (接口或者抽象类) 使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。***

项目中应用：

- ***每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备***
- ***变量的表面类型尽量是接口或者是抽象类***
- ***任何类都不应该从具体类派生***
- ***尽量不要覆写基类的方法***
- ***结合里式替换原则使用***

## 四、接口隔离原则(Interface Segregation Principle)

### 1. 定义

接口的定义：

- **实例接口（Object Interface）**: 即 new 关键字产生的一个实例，它是对一个类型的事物描述，这是一种接口。
- **类接口（Class Interface）**: interface 关键字定义的接口

隔离的定义：

- **客户端不应该依赖它不需要的接口**
- **类间的依赖关系应该建立在最小的接口上**

### 2. 含义

- **接口要尽量小**（***根据接口隔离原则拆分接口时，首先必须满足单一职责原则***）
- **接口要高内聚**
- **定制服务**
- **接口设计是有限度的**

### 3. 实践

- **一个接口只服务于一个子模块或业务逻辑**
- **通过业务逻辑压缩接口中的 public 方法，接口时常去回顾**
- **已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理**
- **了解环境，拒绝盲从，深入了解业务逻辑来设计接口**

## 五、迪米特法则(Law of Demeter，LoD)

​        迪米特法则也成为最少知识原则(Least Knowledge Principle，LKP)，即一个类应该对自己需要耦合或调用的类知道的最少。

迪米特法则含义：

- **只和直接朋友交流**
  - 朋友类：出现在成员变量、方法的输入参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类
- **朋友间也是有距离的**：尽量不要对外公布太多的 public 方法和非静态的 public 变量，尽量内敛，多使用 private、package-private、protected 等访问权限
- **是自己的就是自己的**：如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。
- **谨慎使用 Serializable**: RMI 的时候需要对对象实现 Serializable 接口

迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。不过过渡的解耦会导致系统的复杂性提高，不利于维护，所以在实际应用过程中要反复权衡。

## 六、开闭原则(Open Closed Principle)

​        一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。即尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来完成变化。

软件实体包括:

- 项目或软件产品中按照一定的逻辑规则划分的模块
- 抽象和类
- 方法

开闭原则要求我们在面对上面的软件实体发生的变化时，可以**通过扩展来实现变化**

开闭原则的好处：

- ***开闭原则可以简化单元测试的维护***
- ***开闭原则可以提高复用性***
- ***开闭原则可以提高系统可维护性***
- ***面向对象开发的要求***

如何使用开闭原则：

- ***抽象约束***
  - 通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的 public 方法
  - 参数类型、引用对象尽量使用接口或者抽象类，而不是实现类
  - 抽象层尽量保持稳定，一旦确定即不允许修改

- ***元数据（metadata）控制模块行为***
  - 元数据：用来描述环境和数据的数据，通俗的说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。
- ***制定项目章程***：约定由于配置
- ***封装变化***
  - 将相同的变化封装到一个接口或抽象类中
  - 将不同的变化封装到不同的接口或抽象类中，不应该两个不同的变化出现在同一个接口或抽象类中